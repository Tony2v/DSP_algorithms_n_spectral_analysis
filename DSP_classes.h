#pragma once

#include "Parameters.h"

#ifndef DSP_CLASSES_H
#define DSP_CLASSES_H

#include <arrayfire.h>
#include <string>
#include <vector>

using std::string;

class het_exception
{
private:
	SigParams Sref_params;
	long long Nin;
	long long Nref;
public:
	het_exception(long long ni, long long nr) : Nin(ni), Nref(nr) {};
	~het_exception() {};

	const std::string what()
	{
		if (Nref == 0)
			return std::string("Nref = 0. Probable cause: the signal has not been generated by calling SignalGen().");
		else if (Nin != Nref)
			return std::string("Reference signal and input signal dimension mismatch: Nref != Ninput ");
		else return std::string("Smth else hpnd");
	};
};

class Heterodyne
{
public:	
	Heterodyne();
	Heterodyne(const SigParams & sp, double Vr);
	virtual ~Heterodyne() {};
	
	virtual void reset(const SigParams & sp, double Vr);		// Resetting the new parametres of the signal and target's velocity

	const SigParams& State() const { return Sref_params; };

	af::array process_input(const af::array& S_in) const;

	virtual void SignalGen();

protected:	
	SigParams Sref_params;				// структура с параметрами опорного сигнала
	af::array S_ref;					// generated signal samples
	double Vel;							// velocity' set of heterodyne

};

class LFM_Heterodyne : public Heterodyne
{
public:
	LFM_Heterodyne() : Heterodyne() {};
	LFM_Heterodyne(const SigParams & sp, double Vr) : Heterodyne(sp, Vr) {};
	virtual ~LFM_Heterodyne() {};

	virtual void SignalGen();
	virtual void reset(const SigParams & sp, double Vr);		// Resetting the new parametres of the signal and target's velocity
};


// typedef for vector of Heterodyne functors
typedef std::vector<Heterodyne*> H_vector;

// function to fill that vector with variable numbers of double Velocity parameter
template<class H_vector>
void fill_H_vector(H_vector& hv, const SigParams & sp)
{
	// Do nothing. Finishes the loop.
}

// function to fill that vector with variable numbers of double Velocity parameter
template<class H_vector, class... Args>
void fill_H_vector(H_vector& hv, const SigParams & sp, double Vr, Args...args)
{
	switch (sp.Sig) 
	{
	case SigType::LFM : 
		hv.push_back(new LFM_Heterodyne(sp, Vr));
		break;
	// TODO: U can add case SigType::PSK: hv.push_back(PSK_Heterodyne(sp, Vr)); here

	default: hv.push_back(new Heterodyne(sp, Vr));
	}

	fill_H_vector(hv, sp, args...);
};

#endif